GNU nano 4.9.2                                         hello.c
//#include <linux/module.h>    // included for all kernel modules
//#include <linux/kernel.h>    // included for KERN_INFO
//#include <linux/init.h>      // included for __init and __exit macros
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <asm/uaccess.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Lakshmanan");
MODULE_DESCRIPTION("A Simple Hello World module");

volatile static int is_open = 0;

static char message[1024];
int num_bytes = 0;

//function to handle read. Defines a pointer to a buffer with a size and points to its offset
ssize_t hello_read(struct file * filep, char __user * outb, size_t nbytes, loff_t * offset);
{
    int bytes_read = 0;

    //if there is no starting point in the buffer then return error
    if (offset == NULL) return -1;

    //if the pointer is at the end of the message then it has read the whole message
    if (*offset == num_bytes) return 0;

    //the buffer is in the user data segment, not the kernel segement
    //so we need to have to use "put_user" to copy data from the kernel
    //data segment to the user data segment
    while ((bytes_read < num_bytes) && (*offset < num_bytes)){
        put_user(message[*offset], outp[bytes_read]);
    }

}
//pointer for buffer is mraked as constant as we are handling the writing into the buffer
ssize_t hello_write(struct file * filep, const char __user * inpb, size_t nbytes, loff_t * offset);
    {

    }
int hello_open(struct inode * inodep, struct * filep);
{
    //checking if the device is open and it it is we cannot open something that is already open
    if (is_open == 1){
        printk(KERN_INFO "Error - hello device already open\n");
        return -EBUSY;
    }
    is_open = 1;

    //incrment use count of a module
    //if you tired to remove a module that has a usage count you wont because the module is
            //being used
    try_module_get(THIS_MODULE);
}

//close function
int hello_release(struct inode * inodep, struct * filep);
{
    if (is_open == 0){
        printk(KERN_INFO "Error - hello device is not open\n");
        return -EBUSY;
    }
    is_open == 0;
    module_put(THIS_MODULE);
}
//functions to be stroed in the file operations
struct file_operations fops = {
    read: hello_read,
    write: hello_write,
    open: hello_open,
    release: hello_release
};



static int __init hello_init(void)
{
    printk(KERN_INFO "Hello world!\n");

    strncpy(message,"Hello test.", 1023);
    num_bytes = strlen(message);

    //registering devices we want to create through initialization
    //register_chrdev registers a major number of the device you are initializing
    //setting major number to 0 allows for dynmaic memory allocation
            //This means if a major number is already in use it wont get overwitten.
    //const char name is the name of the device that will appear in "/proc/devices"
    int devnum = register_chrdev(0, "hello", struct file_operations * hello_read);
    printk(KERN_INFO "The hello device is major" %d\n, devnum);

    return 0;    // Non-zero return means that the module couldn't be loaded.
}

static void __exit hello_cleanup(void)
{
    printk(KERN_INFO "Cleaning up module.\n");

}

module_init(hello_init);
module_exit(hello_cleanup);
